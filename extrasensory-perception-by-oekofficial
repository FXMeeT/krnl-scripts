local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local Camera = Workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

local drawings = {}

-- Invert color
local function invertColor(color)
    return Color3.new(1 - color.R, 1 - color.G, 1 - color.B)
end

-- Health color
local function getHealthColor(percentage)
    if percentage > 0.6 then
        return Color3.fromRGB(0, 255, 0)
    elseif percentage > 0.3 then
        return Color3.fromRGB(255, 255, 0)
    else
        return Color3.fromRGB(255, 0, 0)
    end
end

-- Degree to compass (N, NE, etc.)
local function degreesToDirection(deg)
    local dirs = {"N", "NE", "E", "SE", "S", "SW", "W", "NW"}
    local index = math.floor((deg / 45) + 0.5) % 8 + 1
    return dirs[index]
end

-- Angle from vector
local function getDirectionFromLook(vector)
    local angle = math.atan2(vector.X, vector.Z)
    local degrees = math.deg(angle)
    if degrees < 0 then degrees = degrees + 360 end
    return degreesToDirection(degrees), math.floor(degrees)
end

-- Screen box bounds
local function getScreenBounds(corner1, corner2)
    local topLeft = Vector2.new(math.min(corner1.X, corner2.X), math.min(corner1.Y, corner2.Y))
    local size = Vector2.new(math.abs(corner1.X - corner2.X), math.abs(corner1.Y - corner2.Y))
    return topLeft, size
end

RunService.RenderStepped:Connect(function()
    for _, player in pairs(Players:GetPlayers()) do
        local char = player.Character
        local head = char and char:FindFirstChild("Head")
        local hum = char and char:FindFirstChildOfClass("Humanoid")
        local hrp = char and char:FindFirstChild("HumanoidRootPart")

        if player ~= LocalPlayer and head and hum and hrp then
            local headSize = head.Size
            local headCF = head.CFrame
            local bodyCF, bodySize = char:GetBoundingBox()

            local headCorners = {
                headCF:PointToWorldSpace(Vector3.new(-headSize.X/2, -headSize.Y/2, -headSize.Z/2)),
                headCF:PointToWorldSpace(Vector3.new(headSize.X/2, headSize.Y/2, headSize.Z/2))
            }

            local bodyCorners = {
                bodyCF:PointToWorldSpace(Vector3.new(-bodySize.X/2, -bodySize.Y/2, -bodySize.Z/2)),
                bodyCF:PointToWorldSpace(Vector3.new(bodySize.X/2, bodySize.Y/2, bodySize.Z/2))
            }

            local head1, headOn1 = Camera:WorldToViewportPoint(headCorners[1])
            local head2, headOn2 = Camera:WorldToViewportPoint(headCorners[2])
            local body1, bodyOn1 = Camera:WorldToViewportPoint(bodyCorners[1])
            local body2, bodyOn2 = Camera:WorldToViewportPoint(bodyCorners[2])

            if headOn1 and headOn2 and bodyOn1 and bodyOn2 then
                if not drawings[player] then
                    drawings[player] = {
                        HeadBox = Drawing.new("Square"),
                        BodyBox = Drawing.new("Square"),
                        Name = Drawing.new("Text"),
                        Distance = Drawing.new("Text"),
                        HealthText = Drawing.new("Text"),
                        SpeedText = Drawing.new("Text"),
                        DirText = Drawing.new("Text")
                    }

                    for _, obj in pairs(drawings[player]) do
                        if obj.ClassName == "Text" then
                            obj.Size = 16
                            obj.Center = true
                            obj.Outline = true
                        elseif obj.ClassName == "Square" then
                            obj.Thickness = 1
                            obj.Filled = false
                        end
                    end

                    drawings[player].HeadBox.Color = Color3.fromRGB(0, 0, 255)
                    drawings[player].BodyBox.Color = Color3.fromRGB(255, 0, 0)
                    drawings[player].Name.Color = Color3.fromRGB(255, 255, 0)
                end

                local topLeftH, sizeH = getScreenBounds(head1, head2)
                local topLeftB, sizeB = getScreenBounds(body1, body2)

                -- Head box
                drawings[player].HeadBox.Position = topLeftH
                drawings[player].HeadBox.Size = sizeH
                drawings[player].HeadBox.Visible = true

                -- Body box
                drawings[player].BodyBox.Position = topLeftB
                drawings[player].BodyBox.Size = sizeB
                drawings[player].BodyBox.Visible = true

                -- Name
                drawings[player].Name.Text = player.Name
                drawings[player].Name.Position = Vector2.new(topLeftH.X + sizeH.X/2, topLeftH.Y - 18)
                drawings[player].Name.Visible = true

                -- Health
                local healthPerc = math.clamp(hum.Health / hum.MaxHealth, 0, 1)
                drawings[player].HealthText.Text = "Health: " .. tostring(math.floor(healthPerc * 100))
                drawings[player].HealthText.Color = getHealthColor(healthPerc)
                drawings[player].HealthText.Position = Vector2.new(topLeftH.X + sizeH.X/2, topLeftH.Y - 36)
                drawings[player].HealthText.Visible = true

                -- Speed
                drawings[player].SpeedText.Text = "Speed: " .. tostring(math.floor(hum.WalkSpeed))
                drawings[player].SpeedText.Color = Color3.fromRGB(0, 200, 255)
                drawings[player].SpeedText.Position = Vector2.new(topLeftH.X + sizeH.X/2, topLeftH.Y - 54)
                drawings[player].SpeedText.Visible = true

                -- Direction
                local dir, deg = getDirectionFromLook(hrp.CFrame.LookVector)
                drawings[player].DirText.Text = "Direction: " .. dir .. " " .. string.format("%02dÂ°", deg)
                drawings[player].DirText.Color = Color3.fromRGB(180, 180, 255)
                drawings[player].DirText.Position = Vector2.new(topLeftH.X + sizeH.X/2, topLeftH.Y - 72)
                drawings[player].DirText.Visible = true

                -- Distance
                local rayOrigin = Camera.CFrame.Position
                local rayDir = (head.Position - rayOrigin).Unit * 500
                local result = Workspace:Raycast(rayOrigin, rayDir)
                local bgColor = result and result.Instance and result.Instance:IsA("BasePart") and result.Instance.Color or Color3.new(0, 0, 0)

                local dist = math.floor((Camera.CFrame.Position - head.Position).Magnitude)
                drawings[player].Distance.Text = dist .. " studs"
                drawings[player].Distance.Color = invertColor(bgColor)
                drawings[player].Distance.Position = Vector2.new(topLeftB.X + sizeB.X/2, topLeftB.Y + sizeB.Y + 2)
                drawings[player].Distance.Visible = true
            else
                for _, obj in pairs(drawings[player]) do obj.Visible = false end
            end
        elseif drawings[player] then
            for _, obj in pairs(drawings[player]) do obj.Visible = false end
        end
    end
end)
